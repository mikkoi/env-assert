#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Env/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_ASSERT';
  ## no critic [ControlStructures::ProhibitPostfixControls]
  ## no critic [ValuesAndExpressions::ProhibitConstantPragma]
  ## no critic (ControlStructures::ProhibitCascadingIfElse)
  package Env::Assert;
  use strict;
  use warnings;
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
      assert
      report_errors
      file_to_desc
      );
  our %EXPORT_TAGS = (
      'all'          => [qw( assert report_errors file_to_desc )],
  );
  
  use English qw( -no_match_vars ); # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Ensure that the environment variables match what you need, or abort.
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant  {
      ENV_ASSERT_MISSING_FROM_ENVIRONMENT => 1,
      ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE => 2,
      ENV_ASSERT_MISSING_FROM_DEFINITION => 3,
      DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR => 0,
      INDENT => q{    },
  };
  
  =pod
  
  =for stopwords params env
  
  =head1 STATUS
  
  Package Env::Assert is currently being developed so changes in the API are possible.
  
  
  =head1 SYNOPSIS
      use Env::Assert qw( assert );
  
      my %want = (
          options => {
              exact => 1,
          },
          variables => {
              USER => { regexp => '^[[:word:]]{1}$', required => 1 },
          },
      );
      my %parameters;
      $parameters{'break_at_first_error'} = 1;
      my $r = assert( \%ENV, $desc, \%parameters );
      if( ! $r->{'success'} ) {
          say report_errors( $r->{'errors'} );
      }
  
  =head1 NOTES
  
  =cut
  
  =head1 FUNCTIONS
  
  No functions are automatically exported to the calling namespace.
  
  =head2 assert( \%env, \%want, \%params )
  
  Ensure your environment, parameter I<env> (hashref), matches with
  the environment description, parameter I<want> (hashref).
  Use parameter I<params> (hashref) to specify processing options.
  
  Supported params:
  
  =over 8
  
  =item break_at_first_error
  
  Verify environment only up until the first error.
  Then break and return with only that error.
  
  =back
  
  Return: hashref: { success => 1/0, errors => hashref, };
  
  
  =cut
  
  sub assert {
      my ($env, $want, $params) = @_;
      $params = {} if ! $params;
      croak 'Invalid options. Not a hash' if( ref $env ne 'HASH' || ref $want ne 'HASH' );
  
      # Set default options
      $params->{'break_at_first_error'} //= DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR;
  
      my $success = 1;
      my %errors;
      my $vars = $want->{'variables'};
      my $opts = $want->{'options'};
      foreach my $var_name (keys %{ $vars }) {
          my $var = $vars->{$var_name};
          my $required = $var->{'required'}//1;
          my $regexp = $var->{'regexp'}//q{.*};
          if( ( $opts->{'exact'} || $required ) && ! defined $env->{$var_name} ) {
              $success = 0;
              $errors{'variables'}->{ $var_name } = {
                  type => ENV_ASSERT_MISSING_FROM_ENVIRONMENT,
                  message => "Variable $var_name is missing from environment",
              };
              goto EXIT if( $params->{'break_at_first_error'} );
          }
          elsif( $env->{$var_name} !~ m/$regexp/msx ) {
              $success = 0;
              $errors{'variables'}->{ $var_name } = {
                  type => ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE,
                  message => "Variable $var_name has invalid content",
              };
              goto EXIT if( $params->{'break_at_first_error'} );
          }
      }
      if( $opts->{'exact'} ) {
          foreach my $var_name (keys %{ $env }) {
              if( ! exists $vars->{ $var_name } ) {
                  $success = 0;
                  $errors{'variables'}->{ $var_name } = {
                      type => ENV_ASSERT_MISSING_FROM_DEFINITION,
                      message => "Variable $var_name is missing from description",
                  };
                  goto EXIT if( $params->{'break_at_first_error'} );
              }
          }
      }
  
      EXIT:
      return { success => $success, errors => \%errors, };
  }
  
  =head2 report_errors( \%errors )
  
  Report errors in a nicely formatted way.
  
  =cut
  
  sub report_errors {
      my ($errors) = @_;
      my $out = q{};
      $out .= sprintf "Environment Assert: ERRORS:\n";
      foreach my $error_area_name (sort keys %{ $errors }) {
          $out .= sprintf "%s%s:\n", INDENT, $error_area_name;
          foreach my $error_key (sort keys %{ $errors->{$error_area_name} }) {
              $out .= sprintf "%s%s: %s\n", INDENT . INDENT, $error_key,
                  $errors->{$error_area_name}->{$error_key}->{'message'};
          }
      }
      return $out;
  }
  
  =head2 file_to_desc( @rows )
  
  Extract an environment description from a F<.envdesc> file.
  
  =cut
  
  sub file_to_desc {
      my @rows = @_;
      my %desc = ( 'options' => {}, 'variables' => {}, );
      foreach (@rows) {
          # This is envassert meta command
          ## no critic (RegularExpressions::ProhibitComplexRegexes)
          if(
              m{
              ^ [[:space:]]{0,} [#]{2}
              [[:space:]]{1,} envassert [[:space:]]{1,}
              [(] opts: [[:space:]]{0,} (?<opts> .*) [)]
              [[:space:]]{0,} $
              }msx
          ) {
              my $opts = _interpret_opts( $LAST_PAREN_MATCH{opts} );
              foreach ( keys %{ $opts } ) {
                  $desc{'options'}->{$_} = $opts->{$_};
              }
          } elsif(
              # This is comment row
              m{
                  ^ [[:space:]]{0,} [#]{1} .* $
              }msx
          ) {
              1;
          } elsif(
              # This is empty row
              m{
                  ^ [[:space:]]{0,} $
              }msx
          ) {
              1;
          } elsif(
              # This is env var description
              m{
                  ^ (?<name> [^=]{1,}) = (?<value> .*) $
              }msx
          ) {
              $desc{'variables'}->{ $LAST_PAREN_MATCH{name} } = {
                  regexp => $LAST_PAREN_MATCH{value}
              };
          }
      }
      return \%desc;
  }
  
  # Private subroutines
  
  sub _interpret_opts {
      my ($opts_str) = @_;
      my @opts = split qr{
          [[:space:]]{0,} [,] [[:space:]]{0,}
          }msx,
      $opts_str;
      my %opts;
      foreach (@opts) {
          my ($key, $val) = split qr/=/msx;
          $opts{$key} = $val;
      }
      return \%opts;
  }
  
  1;
ENV_ASSERT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

## no critic (ControlStructures::ProhibitPostfixControls)
## no critic (ValuesAndExpressions::ProhibitConstantPragma)
use strict;
use warnings;
use feature qw( say );
use open ':std', IO => ':encoding(UTF-8)';

# ABSTRACT: Ensure that the environment variables match what you need, or abort.

# VERSION: generated by DZP::OurPkgVersion

use English qw( -no_match_vars ); # Avoids regex performance penalty in perl 5.18 and earlier
use Getopt::Long;
use Carp;
use Pod::Usage;

use Env::Assert qw( :all );

local $OUTPUT_AUTOFLUSH = 1;

use constant {
    YEAR_START => 1900,
    MONTH_START => 1,
    ENV_DESC_FILENAME => '.envdesc',
    INDENT => q{    },
};

my $help = 0;
my $man = 0;
my $break_at_first_error;
my $env_desc_filename = ENV_DESC_FILENAME;
GetOptions(
    'help|?' => \$help,
    'man' => \$man,
    'break-at-first-error|b!' => \$break_at_first_error,
    'env-description|e=s' => , \$env_desc_filename,
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;

sub main {

    open my $fh, q{<}, $env_desc_filename or croak "Cannot open file '$env_desc_filename'";
    my $env_desc_file = q{};
    my @env_desc_rows;
    while( <$fh> ) { chomp; push @env_desc_rows, $_; }
    close $fh or croak "Cannot close file '$env_desc_filename'";

    my $desc = file_to_desc( @env_desc_rows );
    my %parameters;
    $parameters{'break_at_first_error'} = $break_at_first_error
        if defined $break_at_first_error;
    my $r = assert( \%ENV, $desc, \%parameters );
    if( ! $r->{'success'} ) {
        ## no critic (InputOutput::RequireCheckedSyscalls)
        say report_errors( $r->{'errors'} );
        return 1;
    }
    return 0;
}

exit main(@ARGV);

__END__

=head1 envassert

Ensure that the environment variables match
what is requested, or abort.

=head1 SYNOPSIS

envassert [options]

Options:
    --help
    --man
    --break-at-error
    --env-description

=head2 CLI interface without dependencies

The F<envassert> command is also available
as self contained executable.
You can download it and run it as it is without
additional installation of CPAN packages.
Of course, you still need Perl, but Perl comes with any
normal Linux installation.

This can be convenient if you want to, for instance,
include F<envassert> in a docker container build.

    curl -LSs -o envassert https://raw.githubusercontent.com/mikkoi/env-assert/master/script/envassert.packed
    chmod +x ./envassert


=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<-b>, B<--break-at-first-error>

Break checking at the first error and report back.
Default: false

=item B<-e>, B<--env-description>

Path to file which has the environment description.
Default: .envdesc

=back

=head1 DESCRIPTION

B<envassert> checks that your runtime environment, as defined
with environment variables, matches with what you want.

You can define your required environment in a file.
Default file is F<.envassert> but you can use any file.
It is advantageous to use B<envassert> for examnple when running
a container. If you check your environment for missing or
wrongly defined environment variables at the beginning of
the container run, your container will fail sooner instead
of in a later point in execution when the variables are needed.

=head2 Environment Description Language

Environment is described in file F<.envdesc>.
Environment description file is a Unix shell compatible file,
similar to a F<.env> file.

=head3 F<.envdesc> Format

In F<.envdesc> file there is only environment variables, comments
or empty rows.
Example:

    # Required env
    ## envassert (opts: exact=1)
    FILENAME=^[[:word:]]{1,}$'

Env var name is followed by a regular expression. The regexp is
an extended Perl regular expression without quotation marks.
One env var and its descriptive regexp use one row.

A comment begins at the beginning of the row and uses the whole row.
It start with '#' character.

Two comment characters and the word B<envassert> at the beginning of the row
mean this is an B<envassert> meta command.
You can specify different environment related options with these commands.

Supported options:

=over 8

=item exact

The option I<exact> means that all allowed env variables
are described in this file. Any unknown env var causes an error
when verifying.

=back

=cut
