#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Env/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENV_ASSERT';
  ## no critic [ControlStructures::ProhibitPostfixControls]
  ## no critic [ValuesAndExpressions::ProhibitConstantPragma]
  ## no critic (ControlStructures::ProhibitCascadingIfElse)
  package Env::Assert;
  use strict;
  use warnings;
  use feature qw( say );
  
  use Exporter 'import';
  our @EXPORT_OK = qw(
      assert
      report_errors
      file_to_desc
      interpret_opts
      );
  our %EXPORT_TAGS = (
      'all'          => [qw( assert report_errors file_to_desc interpret_opts )],
  );
  
  use English qw( -no_match_vars ); # Avoids regex performance penalty in perl 5.18 and earlier
  use Carp;
  
  # ABSTRACT: Ensure that the environment variables match what you need, or abort.
  
  # VERSION: generated by DZP::OurPkgVersion
  
  use constant  {
      ENV_ASSERT_MISSING_FROM_ENVIRONMENT => 1,
      ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE => 2,
      ENV_ASSERT_MISSING_FROM_DEFINITION => 3,
      DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR => 0,
      INDENT => q{    },
  };
  
  =head1 STATUS
  
  Package Env::Assert is currently being developed so changes in the API are possible.
  
  
  =head1 SYNOPSIS
      use Env::Assert qw( env_assert );
  
      my %need = (
          USER => 'random_user',
          HOME => '/home/users/random_user',
      );
      my ($result) = assert( env =>, \%ENV, want => \%need, opts => {
          break_at_first_error => 0
          } );
      if( ! $ok ) {
          print "Errors in environment:\n";
          foreach my $err (@{ $r->{errors} }) { printf "%s\n", $err; }
          exit 1;
      }
  
  =head1 NOTES
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  sub assert {
      my ($env, $want, $params) = @_;
      $params = {} if ! $params;
      croak 'Invalid options. Not a hash' if( ref $env ne 'HASH' || ref $want ne 'HASH' );
  
      # Set default options
      $params->{'break_at_first_error'} //= DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR;
  
      my $success = 1;
      my %errors;
      my $vars = $want->{'variables'};
      my $opts = $want->{'options'};
      foreach my $var_name (keys %{ $vars }) {
          my $var = $vars->{$var_name};
          my $required = $var->{'required'}//1;
          my $regexp = $var->{'regexp'}//q{.*};
          if( ( $opts->{'exact'} || $required ) && ! defined $env->{$var_name} ) {
              $success = 0;
              $errors{'variables'}->{ $var_name } = {
                  type => ENV_ASSERT_MISSING_FROM_ENVIRONMENT,
                  message => "Variable $var_name missing",
              };
              last if( $params->{'break_at_first_error'} );
          }
          elsif( $env->{$var_name} !~ m/$regexp/msx ) {
              $success = 0;
              $errors{'variables'}->{ $var_name } = {
                  type => ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE,
                  message => "Variable $var_name has invalid content",
              };
              last if( $params->{'break_at_first_error'} );
          }
      }
      if( $opts->{'exact'} ) {
          foreach my $var_name (keys %{ $env }) {
              if( ! exists $vars->{ $var_name } ) {
                  $success = 0;
                  $errors{'variables'}->{ $var_name } = {
                      type => ENV_ASSERT_MISSING_FROM_DEFINITION,
                      message => "Variable $var_name missing from definition",
                  };
                  last if( $params->{'break_at_first_error'} );
              }
          }
      }
  
      return { success => $success, errors => \%errors, };
  }
  
  sub report_errors {
      my ($errors) = @_;
      say 'ERRORS:';
      foreach my $error_area_name (keys %{ $errors }) {
          say INDENT . $error_area_name . ': ';
          foreach my $error_key (keys %{ $errors->{$error_area_name} }) {
              say INDENT . INDENT . $error_key . ': ' . $errors->{$error_area_name}->{$error_key}->{'message'};
          }
      }
      return;
  }
  sub file_to_desc {
      my @rows = @_;
      my %tada = ();
      my %desc = ( 'options' => {}, 'variables' => {}, );
      foreach (@rows) {
          # This is envassert meta command
          ## no critic (RegularExpressions::ProhibitComplexRegexes)
          if(
              m{
              ^ [[:space:]]{0,} [#]{2}
              [[:space:]]{1,} envassert [[:space:]]{1,}
              [(] opts: [[:space:]]{0,} (?<opts> .*) [)]
              [[:space:]]{0,} $
              }msx
          ) {
              my $opts = interpret_opts( $LAST_PAREN_MATCH{opts} );
              foreach ( keys %{ $opts } ) {
                  $desc{'options'}->{$_} = $opts->{$_};
              }
          } elsif(
              # This is comment row
              m{
                  ^ [[:space:]]{0,} [#]{1} .* $
              }msx
          ) {
              1;
          } elsif(
              # This is empty row
              m{
                  ^ [[:space:]]{0,} $
              }msx
          ) {
              1;
          } elsif(
              # This is env var description
              m{
                  ^ (?<name> [^=]{1,}) = (?<value> .*) $
              }msx
          ) {
              $desc{'variables'}->{ $LAST_PAREN_MATCH{name} } = {
                  regexp => $LAST_PAREN_MATCH{value}
              };
          }
      }
      return \%desc;
  }
  sub interpret_opts {
      my ($opts_str) = @_;
      my @opts = split qr{
          [[:space:]]{0,} [,] [[:space:]]{0,}
          }msx,
      $opts_str;
      my %opts;
      foreach (@opts) {
          my ($key, $val) = split qr/=/msx;
          $opts{$key} = $val;
      }
      return \%opts;
  }
  
  1;
ENV_ASSERT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

## no critic (ControlStructures::ProhibitPostfixControls)
## no critic (ValuesAndExpressions::ProhibitConstantPragma)
use strict;
use warnings;
use feature qw( say );
use open ':std', IO => ':encoding(UTF-8)';

# ABSTRACT: Ensure that the environment variables match what you need, or abort.

# VERSION: generated by DZP::OurPkgVersion

use English qw( -no_match_vars ); # Avoids regex performance penalty in perl 5.18 and earlier
use Getopt::Long;
use Carp;
use Pod::Usage;

use Env::Assert qw( :all );

local $OUTPUT_AUTOFLUSH = 1;

use constant {
    YEAR_START => 1900,
    MONTH_START => 1,
    ENV_DESC_FILENAME => '.envdesc',
    INDENT => q{    },
};

my $help = 0;
my $man = 0;
my $break_at_first_error;
my $env_desc_filename = ENV_DESC_FILENAME;
GetOptions(
    'help|?' => \$help,
    'man' => \$man,
    'break-at-first-error|b!' => \$break_at_first_error,
    'env-description|e=s' => , \$env_desc_filename,
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;

sub main {

    open my $fh, q{<}, $env_desc_filename or croak "Cannot open file '$env_desc_filename'";
    my $env_desc_file = q{};
    my @env_desc_rows;
    while( <$fh> ) { chomp; push @env_desc_rows, $_; }
    close $fh or croak "Cannot close file '$env_desc_filename'";

    my $desc = file_to_desc( @env_desc_rows );
    use Data::Dumper;
    my %parameters;
    $parameters{'break_at_first_error'} = $break_at_first_error
        if defined $break_at_first_error;
    # say Dumper $desc;
    my $r = assert( \%ENV, $desc, \%parameters );
    # say Dumper $r;
    if( ! $r->{'success'} ) {
        report_errors( $r->{'errors'} );
        return 1;
    }
    return 0;
}

exit main(@ARGV);

__END__

=head1 envassert

Ensure that the environment variables match
what is requested, or abort.

=head1 SYNOPSIS

envassert [options]

Options:
    --help
    --man
    --break-at-error
    --env-description

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<-b>, B<--break-at-first-error>

Break checking at the first error and report back.
Default: false

=item B<-e>, B<--env-description>

Path to file which has the environment description.
Default: .envdesc

=back

=head1 DESCRIPTION

B<envassert> check that your runtime environment, as defined
with environment variables, matches with what you want.

You can define your required environment in a file.
Default file is F<.envassert> but you can use any file.
It is advantageous to use B<envassert> for examnple when running
a container. If you check your environment for missing or
wrongly defined environment variables at the beginning of
the container run, your container will fail sooner instead
of in a later point in execution when the variables are needed.

=head2 Environment Description Language

Environment is described in file F<.envdesc>.
Environment description file is a Unix shell compatible file,
similar to a F<.env> file.

=head3 F<.envdesc> Format

In F<.envdesc> file there is only environment variables, comments
or empty rows.
Example:

    # Required env
    ## envassert (opts: exact=1)
    FILENAME=^[[:word:]]{1,}$'

Env var name is followed be a regular expression. The regexp is
an extended Perl regular expression without quotation marks.
One env var and its descriptive regexp use one row.

A comment begins at the beginning of the row and uses the whole row.
It start with '#' character.

Two comment characters and the word B<envassert> at the beginning of the row
mean this is an B<envassert> command.
You can specify different environment related options with these commands.

Supported options:

=over 8

=item exact

The option I<exact> means that all allowed env variables
are defined in this file. Any unknown env var causes an error
when verifying.

=back

=cut
