## no critic [ControlStructures::ProhibitPostfixControls]
## no critic [ValuesAndExpressions::ProhibitConstantPragma]
## no critic (ControlStructures::ProhibitCascadingIfElse)
package Env::Assert;
use strict;
use warnings;
use feature qw( say );

use Exporter 'import';
our @EXPORT_OK = qw(
    assert
    report_errors
    file_to_desc
    interpret_opts
    );
our %EXPORT_TAGS = (
    'all'          => [qw( assert report_errors file_to_desc interpret_opts )],
);

use English qw( -no_match_vars ); # Avoids regex performance penalty in perl 5.18 and earlier
use Carp;

# ABSTRACT: Ensure that the environment variables match what you need, or abort.

# VERSION: generated by DZP::OurPkgVersion

use constant  {
    ENV_ASSERT_MISSING_FROM_ENVIRONMENT => 1,
    ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE => 2,
    ENV_ASSERT_MISSING_FROM_DEFINITION => 3,
    DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR => 0,
    INDENT => q{    },
};

=head1 STATUS

Package Env::Assert is currently being developed so changes in the API are possible.


=head1 SYNOPSIS
    use Env::Assert qw( env_assert );

    my %need = (
        USER => 'random_user',
        HOME => '/home/users/random_user',
    );
    my ($result) = assert( env =>, \%ENV, want => \%need, opts => {
        break_at_first_error => 0
        } );
    if( ! $ok ) {
        print "Errors in environment:\n";
        foreach my $err (@{ $r->{errors} }) { printf "%s\n", $err; }
        exit 1;
    }

=head1 NOTES

=cut

=head1 FUNCTIONS

=cut

sub assert {
    my ($env, $want, $params) = @_;
    $params = {} if ! $params;
    croak 'Invalid options. Not a hash' if( ref $env ne 'HASH' || ref $want ne 'HASH' );

    # Set default options
    $params->{'break_at_first_error'} //= DEFAULT_PARAMETER_BREAK_AT_FIRST_ERROR;

    my $success = 1;
    my %errors;
    my $vars = $want->{'variables'};
    my $opts = $want->{'options'};
    foreach my $var_name (keys %{ $vars }) {
        my $var = $vars->{$var_name};
        my $required = $var->{'required'}//1;
        my $regexp = $var->{'regexp'}//q{.*};
        if( ( $opts->{'exact'} || $required ) && ! defined $env->{$var_name} ) {
            $success = 0;
            $errors{'variables'}->{ $var_name } = {
                type => ENV_ASSERT_MISSING_FROM_ENVIRONMENT,
                message => "Variable $var_name missing",
            };
            goto EXIT if( $params->{'break_at_first_error'} );
        }
        elsif( $env->{$var_name} !~ m/$regexp/msx ) {
            $success = 0;
            $errors{'variables'}->{ $var_name } = {
                type => ENV_ASSERT_INVALID_CONTENT_IN_VARIABLE,
                message => "Variable $var_name has invalid content",
            };
            goto EXIT if( $params->{'break_at_first_error'} );
        }
    }
    if( $opts->{'exact'} ) {
        foreach my $var_name (keys %{ $env }) {
            if( ! exists $vars->{ $var_name } ) {
                $success = 0;
                $errors{'variables'}->{ $var_name } = {
                    type => ENV_ASSERT_MISSING_FROM_DEFINITION,
                    message => "Variable $var_name missing from definition",
                };
                goto EXIT if( $params->{'break_at_first_error'} );
            }
        }
    }

    EXIT:
    return { success => $success, errors => \%errors, };
}

sub report_errors {
    my ($errors) = @_;
    ## no critic (InputOutput::RequireCheckedSyscalls)
    say 'ERRORS:';
    foreach my $error_area_name (keys %{ $errors }) {
        say INDENT . $error_area_name . ': ';
        foreach my $error_key (keys %{ $errors->{$error_area_name} }) {
            say INDENT . INDENT . $error_key . ': ' . $errors->{$error_area_name}->{$error_key}->{'message'};
        }
    }
    return;
}
sub file_to_desc {
    my @rows = @_;
    my %tada = ();
    my %desc = ( 'options' => {}, 'variables' => {}, );
    foreach (@rows) {
        # This is envassert meta command
        ## no critic (RegularExpressions::ProhibitComplexRegexes)
        if(
            m{
            ^ [[:space:]]{0,} [#]{2}
            [[:space:]]{1,} envassert [[:space:]]{1,}
            [(] opts: [[:space:]]{0,} (?<opts> .*) [)]
            [[:space:]]{0,} $
            }msx
        ) {
            my $opts = interpret_opts( $LAST_PAREN_MATCH{opts} );
            foreach ( keys %{ $opts } ) {
                $desc{'options'}->{$_} = $opts->{$_};
            }
        } elsif(
            # This is comment row
            m{
                ^ [[:space:]]{0,} [#]{1} .* $
            }msx
        ) {
            1;
        } elsif(
            # This is empty row
            m{
                ^ [[:space:]]{0,} $
            }msx
        ) {
            1;
        } elsif(
            # This is env var description
            m{
                ^ (?<name> [^=]{1,}) = (?<value> .*) $
            }msx
        ) {
            $desc{'variables'}->{ $LAST_PAREN_MATCH{name} } = {
                regexp => $LAST_PAREN_MATCH{value}
            };
        }
    }
    return \%desc;
}
sub interpret_opts {
    my ($opts_str) = @_;
    my @opts = split qr{
        [[:space:]]{0,} [,] [[:space:]]{0,}
        }msx,
    $opts_str;
    my %opts;
    foreach (@opts) {
        my ($key, $val) = split qr/=/msx;
        $opts{$key} = $val;
    }
    return \%opts;
}

1;
